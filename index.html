<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard App</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div id="app" class="bg-blue-50 rounded-3xl p-6 w-full max-w-md shadow-lg">
        <!-- Category Selector -->
        <select id="category" class="w-full p-2 mb-4 text-lg rounded-lg bg-blue-600 text-white focus:outline-none">
            <option value="Danh t·ª´ (n)">Danh t·ª´ (n)</option>
            <option value="T√≠nh t·ª´ (adj)">T√≠nh t·ª´ (adj)</option>
            <option value="ƒê·ªông t·ª´ (v)">ƒê·ªông t·ª´ (v)</option>
            <option value="Tr·∫°ng t·ª´ (adv)">Tr·∫°ng t·ª´ (adv)</option>
        </select>

        <!-- Word Display -->
        <div id="word-label" class="text-2xl font-bold text-blue-900 mb-4 text-center">...</div>

        <!-- Input Box -->
        <input id="answer-input" type="text" placeholder="Nh·∫≠p nghƒ©a ti·∫øng Anh" class="w-full p-2 mb-4 text-lg rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">

        <!-- Feedback Label -->
        <div id="feedback-label" class="text-lg font-bold mb-4 text-center"></div>

        <!-- Button Row -->
        <div class="flex justify-between mb-4">
            <button id="check-btn" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600">‚úîÔ∏è Ki·ªÉm tra</button>
            <button id="show-btn" class="bg-yellow-500 text-white px-4 py-2 rounded-lg hover:bg-yellow-600">üí° Hi·ªán ƒë√°p √°n</button>
            <button id="next-btn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600">‚û°Ô∏è Ti·∫øp</button>
        </div>

        <!-- Progress Label -->
        <div id="progress-label" class="text-sm text-gray-600 text-center">0/0</div>
    </div>

    <script>
        // Vocabulary Data
        const DATA = {
            "Danh t·ª´ (n)": {
                "th√†nh t·ª±u": ["achievement"],
                "l·ª£i √≠ch": ["benefit"],
                "s·ª± g·∫Øn b√≥": ["bond"],
                "tr·ª• c·ªôt gia ƒë√¨nh": ["breadwinner"],
                "t√≠nh c√°ch": ["character"],
                "l·ª±a ch·ªçn": ["choice"],
                "v·∫•n ƒë·ªÅ kh√≥ khƒÉn": ["difficulty"],
                "l√≤ng bi·∫øt ∆°n": ["gratitude"],
                "th·ª±c ph·∫©m t·∫°p h√≥a": ["grocery"],
                "mang v√°c n·∫∑ng": ["heavy lifting"],
                "ng∆∞·ªùi n·ªôi tr·ª£": ["homemaker"],
                "c√¥ng vi·ªác nh√†": ["household chore", "housework"],
                "qu·∫ßn √°o, ƒë·ªì gi·∫∑t l√†": ["laundry"],
                "danh s√°ch": ["list"],
                "phong c√°ch, c√°ch ·ª©ng x·ª≠": ["manner"],
                "s·ª± t√¥n tr·ªçng": ["respect"],
                "tr√°ch nhi·ªám": ["responsibility"],
                "k·∫øt qu·∫£": ["result"],
                "c√¥ng vi·ªác h√†ng ng√†y": ["routine"],
                "r√°c r∆∞·ªüi": ["rubbish"],
                "s·ª± th√†nh c√¥ng": ["success"],
                "h·ªó tr·ª£": ["support"],
                "nhi·ªám v·ª•": ["task"],
                "gi√° tr·ªã": ["value"],
                "r·ª≠a b√°t": ["washing up"]
            },
            "T√≠nh t·ª´ (adj)": {
                "c√¥ng b·∫±ng": ["fair"],
                "th·∫≠t th√†": ["honest"],
                "trung th·ª±c": ["truthful"]
            },
            "ƒê·ªông t·ª´ (v)": {
                "bi·∫øt ∆°n, tr√¢n tr·ªçng": ["appreciate"],
                "t·ªï ch·ª©c ti·ªác": ["celebrate"],
                "c·ªï v≈©, l√†m cho vui l√™n": ["cheer up"],
                "n·∫•u ƒÉn": ["cook"],
                "ph√° h·ªèng": ["damage"],
                "th·ªèa thu·∫≠n": ["discuss"],
                "chia": ["divide"],
                "tr∆∞·ªüng th√†nh": ["grow up"],
                "kƒ© nƒÉng s·ªëng": ["life skill"],
                "xoay s·ªü": ["manage"],
                "chu·∫©n b·ªã": ["prepare"],
                "v·ª©t": ["put out"],
                "nu√¥i n·∫•ng": ["raise"],
                "h·ªó tr·ª£": ["support"]
            },
            "Tr·∫°ng t·ª´ (adv)": {
                "thay cho": ["instead of"],
                "kh√¥ng t√¨ v·∫øt": ["spotlessly"],
                "nhanh ch√≥ng": ["quickly"],
                "ch·∫≠m ch·∫°p": ["slowly"],
                "c·∫©n th·∫≠n": ["carefully"],
                "th∆∞·ªùng xuy√™n": ["usually"],
                "hi·∫øm khi": ["rarely"],
                "lu√¥n lu√¥n": ["always"],
                "ƒë√¥i khi": ["sometimes"],
                "ng√†y h√¥m qua": ["yesterday"],
                "h√¥m nay": ["today"],
                "ng√†y mai": ["tomorrow"]
            }
        };

        // Initialize state
        let category = "Danh t·ª´ (n)";
        let words = Object.keys(DATA[category]);
        words.sort(() => Math.random() - 0.5); // Shuffle words
        let index = 0;
        let correct = 0;
        let attempts = 0;

        // Load audio
        const soundCorrect = new Audio("applepay.mp3");
        const soundWrong = new Audio("vine-boom.mp3");

        // DOM elements
        const categorySelect = document.getElementById("category");
        const wordLabel = document.getElementById("word-label");
        const answerInput = document.getElementById("answer-input");
        const feedbackLabel = document.getElementById("feedback-label");
        const checkBtn = document.getElementById("check-btn");
        const showBtn = document.getElementById("show-btn");
        const nextBtn = document.getElementById("next-btn");
        const progressLabel = document.getElementById("progress-label");

        // Show current word
        function showWord() {
            if (index < words.length) {
                const current = words[index];
                wordLabel.textContent = `T·ª´ ti·∫øng Vi·ªát: ${current}`;
                answerInput.value = "";
                feedbackLabel.innerHTML = "";
                progressLabel.textContent = `Ti·∫øn ƒë·ªô: ${index}/${words.length}`;
            } else {
                wordLabel.textContent = "üéâ ƒê√£ h·ªçc xong!";
                feedbackLabel.innerHTML = `ƒê√∫ng ${correct}/${attempts}`;
                progressLabel.textContent = "Ho√†n th√†nh";
            }
        }

        // Change category
        categorySelect.addEventListener("change", (e) => {
            category = e.target.value;
            words = Object.keys(DATA[category]);
            words.sort(() => Math.random() - 0.5); // Shuffle words
            index = 0;
            correct = 0;
            attempts = 0;
            showWord();
        });

        // Check answer
        checkBtn.addEventListener("click", () => {
            if (index < words.length) {
                const current = words[index];
                const user = answerInput.value.trim().toLowerCase();
                const valid = DATA[category][current].map(a => a.toLowerCase());

                attempts++;
                if (valid.includes(user)) {
                    correct++;
                    feedbackLabel.innerHTML = '<span class="text-green-600">‚úÖ ƒê√∫ng r·ªìi!</span>';
                    soundCorrect.play();
                } else {
                    feedbackLabel.innerHTML = '<span class="text-red-600">‚ùå Sai, th·ª≠ l·∫°i!</span>';
                    soundWrong.play();
                }
                progressLabel.textContent = `Ti·∫øn ƒë·ªô: ${index}/${words.length}`;
            }
        });

        // Show answer
        showBtn.addEventListener("click", () => {
            if (index < words.length) {
                const current = words[index];
                const valid = DATA[category][current];
                feedbackLabel.innerHTML = `<span class="text-blue-600">ƒê√°p √°n: ${valid.join(", ")}</span>`;
            }
        });

        // Next word
        nextBtn.addEventListener("click", () => {
            if (index < words.length) {
                index++;
                showWord();
            }
        });

        // Initialize
        showWord();
    </script>
</body>
</html>